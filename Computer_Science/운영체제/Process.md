# 프로세스

## 프로그램 vs 프로세스

- 프로그램: 보조기억장치에 존재하며 실행되기를 기다리는 명령어와 정적인 데이터의 묶음
- 프로세스: 프로그램의 명령어와 정적 데이터가 메모리에 적재되면 프로세스

## 하나의 CPU에서 여러 개의 프로세스 동시 실행?

- 원래는 하나의 CPU는 한 순간에 하나의 프로세스만 실행가능
- 운영체가가 CPU가 실행할 프로세스를 빠르게 교체하므로 동시에 여러개의 프로세스가 실행 되는 것과 같이

## 프로세스의 구성

- 프로세스에 대한 정보는 프로세스 제어블록(PCB, Process Control Block)또는 프로세스 기술자(Process Descriptor)라고 부르는 자료구조에 저장, 대부분 PCB라고 부름
- PCB는 다음과 같은 정보를 담고 있다.

- PID

> 운영체제가 각 프로세스를 식별하기 위해 부여된 프로세스 식별번호(PID, Process IDentification)

- 프로세스 상태

> CPU는 프로세스를 빠르게 교체하면서 실행하기 때문에 실행중인 프로세스도 있고 대기중인 프로세스도 있다. 그런 프로세스의 상태를 저장

- 프로그램 카운터

> CPU가 다음으로 실행할 명령어를 가리키는 값, CPU는 기계어를 한 단위씩 읽어서 처리하는데 프로세스를 실행하기 위해 다음으로 실행할 기계어가 저장된 메모리 주소를 가리키는 값

- 스케줄링 우선순위

> 운영체제는 여러개의 프로세스를 동시에 실행하는 것 처럼 보이게 해 줌, 운영체제가 여러 개의 프로세스가 CPU에서 실행되는 순서를 결정 하는 것을 스케줄링, 스케줄링에서 우선순위가 높은 것 부터 먼저 실행

- 권한

> 프로세스가 접근할 수 있는 자원을 결정하는 정보, 예를 들어 아무 앱이나 휴대폰의 통화내역에 접근이 가능 하다면 악의적 이용이 가능, 프로세스마다 어디까지 접근할 수 있는지에 대한 권한 필요

- 프로세스의 부모와 자식 프로세스

> 최초로 생성되는 init프로세스를 제외하고 모든 프로세스는 부모 프로세스를 복제해서 생성되고 이 계층관계는 트리를 형성, 따라서 각 프로세스는 자식 프로세스와 부모 프로세스에 대한 정보를 가짐

- 프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터

> 프로세스는 실행중인 프로그램, 따라서 프로그램에 대한 정보가 필요, 프로그램에 대한 정보는 프로세스가 메모리에 가지는 자신만의 주소 공간에 저장, 이 공간에 대한 포인터 값을 가짐

- 실행문맥

> 프로세스가 실행상태에서 마지막으로 실행한 프로세서의 레지스터 내용, CPU에 의해 실행되는 프로세스는 운영체제에 의해 계속 교체되는데, 교체되었다가 다시 자신의 차례가 되어서 실행될때 중단된적 없고 마치 연속적으로 실행된것처럼하기 위해 이 레지스터 정보를 가짐

- 프로세스에 할당된 자원들을 가리키는 포인터

### 프로세스가 접근 할 수 있는 메모리 공간

- 프로세스의 데이터와 명령어가 있는 메모리
- Text, Data, BSS, Heap, Stack 영역으로 구성
- 아래 그림에서 각 영역에 프로그램의 어떤 정보를 저장하는지 나타냄
- Stack과 Heap사이의 빈 공간은 컴파일 타임에 지역변수를 얼마나 사용할 지 미리 계산할 수 없기 때문에, 런타임에 지역변수 선언 순서에 따라 Stack은 위쪽으로 주소 값을 매기고 동적할당, Heap은 아래쪽으로 주소 값을 매김

![프로세스 메모리](../assets/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B3%B5%EA%B0%84.jpg)


## 프로세스 상태

- 운영체제는 프로세스들의 실행 사이에 프로세스를 교체하고 재시작할 때 오류가 발생하지 않도록 관리 이를 위해 운영체제는 프로세스의 상태를 상태전이를 통해 체계적으로 관리합니다.

![관리](../assets/500px-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png)

1. 프로그램을 실행하면 프로세스가 생성되고 준비리스트에 추가
2. 프로세스는 프로세서(CPU)가 사용가능한 상태가 되면 할당받음, 이를 준비상태에서 실행상태로 상태전이된다고 함, 이 과정을 dispatching이라고 하고 dispatcher가 이 일을 수행
3. 프로세스는 실행상태에서 CPU를 이용해 연산한 후 CPU를 자발적으로 반납하고 작업이 끝나지 않았으면 대기 상태로 들어감
4. 운영체제는 다시 준비리스트의 첫번째에 있는 프로세스를 실행상태로 바꾸고 1-4를 반복

- 운영체제는 프로세스가 CPU를 자발적으로 반납하지 않고 독점하는 경우를 방지하기 위해 하드웨어적으로 인터럽팅 클록을 주기적으로 발생, 프로세스가 특정 시간 간격동안만 실행할 수 있도록 함, 인터럽팅 클록이 발생되면 강제로 실행중인 프로세스의 CPU제어권을 운영체제에게 뺏기고 프로세스는 준비상태로 전이
- 프로세스를 다시 사용하기 전 입출력이 완료대기를 기다려야 하는 상황이라면 완료될때까지 자신을 대기, 입출력이 완료되면 운영체제가 프로세스를 대기상태에서 준비상태로 전이